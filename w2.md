## Mục lục 
- [1. Về Version Control System(VCS)](#Ve_VCS)
  - [1.1. Khái niệm](#VCS_khai_niem)
  - [1.2. Các VCS cục bộ](#VCS_cuc_bo)
  - [1.3. Các VCS tập trung](#CVCS)
  - [1.4. Các VCS phân tán](#DVCS)
- [2. Git basic](#git_basic)
  - [2.1. Tạo kho chứa mới](#creat)
  - [2.2. Ghi lại thay đổi vào kho chứa](#change)
    - [2.2.1. Kiểm tra trạng thái](#status)
    - [2.2.2. Bắt đầu theo dõi một tệp mới được bổ sung](#track)
    - [2.2.3. Staging](#staging)
    - [2.2.4. Ignoring](#ignoring)
    - [2.2.5. Xem lại chi tiết các thay đổi](#view_change)
    - [2.2.6. Commit](#commit)
    - [2.2.7. Bỏ qua stage](#bo_qua)
    - [2.2.8. Xóa file](#xoa)
  - [2.3. Xem lại lịch sử các commit](#history)
  - [2.4. Undo](#undo)
    - [2.4.1. Unstage](#unstage)
    - [2.4.2. Unmodified](#unmodified)
  - [2.5. Làm việc với các kho chứa từ xa](#remote)
    - [2.5.1. Hiển thị các kho chứa từ xahiện có](#view_remote)
    - [2.5.2. Thêm kho chứa từ xa mới](#add_remote)
    - [2.5.3. Fetch vs pull](#fetch_pull)
    - [2.5.4. Push](#push)
    - [2.5.5. Xem nhiều thông tin hơn](#inspect)
    - [2.5.6. Đổi tên và xóa server](#rename)
  - [2.6. Tagging](#tagging)
    - [2.6.1. Xem các tag hiện có](#view_tag)
    - [2.6.2. Tạo tag](#creat_tag)
    - [2.6.3. Đánh tag muộn](#tag_late)
    - [2.6.4. Chia sẻ tag](#tag_share)
  - [2.7. Alias](#alias)
- [3. Branch](#branch)
  - [3.1. Tổng quan về nhánh](#over)
    - [3.1.1. Khái niệm nhánh](#khai_niem)
    - [3.1.2. Tạo nhánh](#creat_branch)
    - [3.1.3. Chuyển nhánh](#switch)
  - [3.2. Phân nhánh và hợp nhánh](#pnhn)
    - [3.2.1. Phân nhánh](#pn)
    - [3.2.2. Hợp nhánh](#hn)
    - [3.2.4. XUng đột khi hợp](#conflict)
  - [3.3. Quản lí nhánh](#quan_li)
  - [3.4. Nhánh từ xa](#remote_branch)
    - [3.4.1. Pushing](#pushing)
    - [3.4.2. Tracking branch](#tracking)
    - [3.4.3. Pulling](#pulling)
    - [3.4.4. Xóa nhánh từ xa](#xoa)
  - [3.5. Rebase](#rebase)
- [4. Tài liệu tham khảo](#tailieu)

<a name="Ve_VCS"></a>
## Về Version Control System(VCS)
<a name="VCS_khai_niem"></a>
1. Khái niệm

  VCS là hệ thống dùng để ghi lại các thay đổi trên file hoặc tập các file để dễ dàng gọi lại các phiên bản nhất định sau này. 
  Nó cho phép ta đưa 1 file về trạng thái trước đó, đưa toàn bộ project về trạng thái cũ, quan sát các thay đổi, xem người thay đổi là ai, ai làm hỏng code...
<a name="VCS_cuc_bo></a>
2. Các VCS cục bộ

   Cách đơn giản nhất để quản lí code là copy các file ra 1 thư mục khác (tỉnh táo hơn thì có gắn nhãn thời gian). Phương pháp này rất phổ biến vì nó đơn giản, nhưng rất dễ xảy ra lỗi. Có thể quên chỗ để thư mục, vô tình ghi nhầm file hay là copy nhầm file mà ta không có ý định làm thế.

   Để giải quyết vấn đề này, các nhà làm phần mềm đã làm ra các VCS cục bộ. Các VCS này có cơ sở dữ liệu lưu lại toàn bộ thay đổi trên file.

    ![](https://git-scm.com/book/en/v2/images/local.png)
    
   Một trong các phần mềm nổi tiếng là RCS, vẫn còn được dùng trên nhiều máy tính đến ngày nay. RCS hoạt động bằng cách lưu tất cả các thay đổi trên file bằng 1 định dạng đặc biệt, khi cần khôi phục trạng thái thì file sẽ được sửa bằng các phần này.
<a name="CVCS"></a>
3. Các VCS tập trung

   Bây giờ, khi quản lí trên máy cá nhân được rồi thì người ta lại đặt yêu cầu cao hơn là làm việc với bạn bè, người thân,... Để giải quyết vấn đề này, các nhà làm phần mềm lại nghĩ ra VCS tập trung. Các hệ thống này có 1 server ở trung tâm lưu giữ phiên các file, ai muốn làm việc cùng thì kết nối tới và copy phiên bản mới nhất về.

   ![](https://git-scm.com/book/en/v2/images/centralized.png)
   
   Cách làm này có nhiều ưu điểm, đặc biệt trên các VCS cục bộ. Mọi người đều biết người khác đang làm gì. Quản trị viên có quyền kiểm soát chặt chẽ với việc phát quyên cho mỗi người, quản trị CVCS dễ dàng hơn nhiều so với quản trị cơ sở dữ liệu cục bộ trên mỗi client.
    
   Tuy nhiên, vấn đề lớn gặp phải là "single point of failure". Nếu server chết trong 1 giờ thôi thì mọi người chẳng đóng góp gì lên được nữa hoặc là lấy dữ liệu về. Xấu hơn là là ở đĩa trên server bị hỏng ta mất tất cả mọi thứ, toàn bộ lịch sử của project ngoại trừ vài phần trên các máy client. Bất cứ khi nào lưu toàn bộ thông tin tại 1 vị trí thì nguy cơ mất hết là luôn thường trực.
    
<a name="DVCS"></a>
4. Các VCS phân tán(DVCS)

   Khác với cách tiếp cận của CVCS, client không chỉ lấy phiên bản mới nhất của các file về mà có toàn bộ lịch sử của project. Thế nên kể cả server mất hết dữ liệu thì chỉ cần copy của 1 client về là được. Mỗi bản sao trên client là 1 bản sao lưu của toàn bộ dữ liệu trên server.

   ![](https://git-scm.com/book/en/v2/images/distributed.png)
   
   Ta có các hệ tiêu biểu: Git, Mercurial, Bazaar or Darcs...
<a name="git_basic"></a>
## Git basic
<a name="creat"></a>
### Tạo kho chứa mới

- 2 cách để tạo 1 kho chứa Git
     + Chọn 1 thư mục trên máy tính và tạo thành kho chứa
     + Sao kho chứa từ máy khác 
- Tạo kho chứa từ 1 thư mục trên máy:
Di chuyển thư mục làm việc hiện tại đến thư mục này và thực hiện câu lệnh: 
``` git init```
Việc này tạo ra 1 thư mục .git mới chứa mọi file cần thiết của kho chứa. Tuy nhiên, vẫn chưa có gì được lưu dấu.
Để có thể kiểm soát thư mục này bằng Version-control cần phải bắt đầu lưu dấu và tạo 1 commit đầu tiên bằng 1 vài câu lệnh ``` git add``` và ```git commit``` sẽ được đề cập sau.
- Sao kho chứa từ máy khác về
Sử dụng câu lệnh ```git clone <url>```, ví dụ:
```git clone https://github.com/libgit2/libgit2```
Việc này sẽ tạo ra trong máy 1 thư mục mới tên là libgit2, tạo 1 thư mục .git bên trong, kéo tât cả dữ liệu xuống cho thư mục này, tạo ra 1 thư mục làm việc dựa trên phiên bản mới nhất. Nếu ta đi đến thư mục libgit2 này, ta sẽ thấy project đang sẵn sàng để làm việc.

<a name="change"></a>
### Ghi lại thay đổi vào kho chứa

Mỗi tệp trong thư mục làm việc có thể có 2 trạng thái: tracked và untracked.
Tracked là các tệp mà git đã biết, đã có trong ảnh chụp về project gần đây nhất, còn untracked là các file chưa có trong ảnh chụp này.
<a name="status"></a>
1. Kiểm tra trạng thái của 1 file 

Để kiểm tra trạng thái của các file sử dụng câu lệnh ```git status```. Nếu ta chạy câu lệnh này sau khi clone thì sẽ thấy kết quả như sau:

    ```
    $ git status
    On branch master
    Your branch is up-to-date with 'origin/master'.
    nothing to commit, working directory clean
    ```
    
    Kết quả cho ta biết nhánh mà ta đang đứng, không có khác biệt nào so với nhánh này trên server, "working directory clean" có nghĩa là không có tệp đã được tracked nào bị thay đổi.
Nếu ta tạo ra 1 tệp mới chưa có trong project, khi chạy lệnh ta sẽ nhận được kết quả như sau:

    ```
    $ git status
    On branch master
    Your branch is up-to-date with 'origin/master'.
    Untracked files:
    (use "git add <file>..." to include in what will be committed)
    
    README
    
    nothing added to commit but untracked files present (use "git add" to track)
    ```
    README là file có trạng thái là untracked, Git sẽ không cho file này vào trong commit tới nếu ta không bắt nó làm. Điều này tránh trường hợp ta commit cả mấy file rác vào trong project. Nếu muốn commit nó lên, hãy bắt đầu bằng tracking nó.
<a name="track"></a>    
2. Bắt đầu heo dõi(Tracking) một tệp mới được bổ sung

Để bắt đầu tracking 1 file, ta sử dụng câu lệnh ```git add```. Ví dụ, để bắt đầu theo dõi file README ở trên:
```$ git add README```
Nếu ta chạy lệnh ```git status``` lần nữa, ta sẽ thấy như sau:

    ```
    $ git status
    On branch master
    Your branch is up-to-date with 'origin/master'.
    Changes to be committed:
    (use "git reset HEAD <file>..." to unstage)
  
    new file:   README
    ```
    File này nằm ở trạng thái staged có nghĩa là sẽ được ghi vào ảnh chụp toàn bộ project vào lần commit kế tiếp. Nếu sử dụng câu lệnh ```git add``` với tham số là đường dẫn là thư mục thì toàn bộ các file trong thư mục sẽ được đánh dấu là staged và được chụp lại trong lần commit kế.
<a name="staging"></a>
3. Staging

Nếu ta sửa 1 file đã được tracked, file này sẽ được đánh dấu là modified nhưng chưa phải là staged. Có nghĩa là nó sẽ không được đưa vào ảnh chụp của project trong lần commit kế tiếp.
Nếu muốn đưa nó vào ảnh chụp, ta cần sử dụng câu lệnh ```git add```. Phiên bản của file được chụp sẽ là trước khi chạy lệnh ```git add``` chứ không phải trước lệnh ```git commit```, nếu có bất kì thay đổi nào sau khi chạy lệnh ```git add``` thì ta cần chạy ```git add``` lại lần nữa để những ghi lại những thay đổi này.

<a name="ignoring"></a>
4. Ignoring

Những file tự sinh thường không nên được add hoặc là kể cả hiển thị trạng thái tracked hay chưa. Ta có thể chỉ ra danh sách các file này trong file .gitignore để git biết và không tự động add nó vào trong commit. 
Nội dung file này là các mẫu (pattern):
    - Dòng trống hoặc bắt đầu với dấu # được bỏ qua
    - Các biểu thức chính quy, được áp dụng 1 cách đệ quy cho toàn bộ thư mục
    - Đặt dấu / ở trước pattern để tránh đệ quy
    - Đặt dấu / ở cuối pattern để chỉ rõ 1 thư mục
    - Đặt dấu ! ở đầu để phủ định 1 pattern 
Thường có 1 file .gitignore ở thư mục gốc, áp dụng cho toàn bộ các thư mục con. Tuy nhiên cũng có trường hợp các file .gitignore đặt ở các thư mục con, sẽ được áp dụng chỉ cho các file dưới mục này.

<a name="view_change"></a>
5. Xem lại chi tiết các thay đổi
         
Nếu câu lệnh ```git status``` chưa đem lại đủ thông tin, ta có thể sử dụng ```git diff```.
Câu lệnh này cho kết quả các thay đổi đã được tạo ra mà chưa được đánh dấu staged, nếu ta đánh dấu tất cả thay đổi là staged thì kết quả sẽ không có gì cả.
Sử dụng lệnh ```git diff --staged``` để xem những thứ đã được đánh dấu staged cho lần commit kế tiếp.

<a name="commit"></a>
6. Commit

Sau khi đã quyết định cái gì cần được ghi lại bằng việc đánh dấu staged(```git add```)  thì ta có thể commit nó, ghi vào kho chứa. 
```git commit```
Sau khi thực hiện câu lệnh thì trình soạn thảo được bật lên và ta có thể nhập vào 1 thông điệp để ghi nhớ việc ta đã làm. CŨng có thể sử dụng thêm tùy chọn -m trong câu lệnh ```git add``` và thông điệp cần ghi nhớ luôn cho nhanh. Ví dụ: 
```git add -m "message"```

<a name="bo_qua"></a>
7. Bỏ qua staged

Để có thể commit luôn mà không cần đánh dấu file nào là stage ta sử dụng câu lệnh ```git commit``` với tùy chọn -a, tất cả các file được sửa đổi sẽ được commit vào kho chứa.

<a name="xoa"></a>
8. Xóa file

Để xóa 1 file trong git, ta cần xóa nó khỏi danh sách các file đã được track và sau đó commit. VIệc này có thể được thực hiện bằng câu lệnh ```git rm```, file sẽ được xóa luôn khỏi thư mục làm việc nên ta sẽ không thấy file nào là untracked cả.
Sử dụng ```git rm``` với tùy chọn là -- cached khi muốn untracked 1 file nhưng không muốn nó bị xóa trong thư mục làm việc.
```git rm``` có thể nhận tham số là tên file hoặc là 1 pattern đại diện cho 1 nhóm các tên file ví dụ:```$ git rm log/\*.log``` sẽ xóa tất cả các file có đuôi là .log trong thư mục log

<a name="history"></a>
### Xem lịch sử các commit

Sau khi thực hiện vài commit hoặc mới clone 1 project từ trên mạng về ta muốn xem ai đã làm gì với project này. Công cụ hữu hiệu nhất là ```git log```
Mặc định nếu không có tham số nào thì ```git log``` cho kết quả danh sách các commit theo theo thứ tự gần đây nhất. Mỗi commit được được liệt kê với 1 mã SHA-1 checksum, tên tác giả và email, ngày tạo commit và thông điệp commit. Ví dụ:

```$ git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit
```
Có rất nhiều tùy chọn cho câu lệnh này để ta có thể tìm kiếm thông tin 1 cách hiệu quả. 
Có thể sử dụng tùy chọn -p để hiển thị khác biệt giữa mỗi lần commit. Ví dụ
```$ git log -p -2
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
--- a/Rakefile
+++ b/Rakefile
@@ -5,7 +5,7 @@ require 'rake/gempackagetask'
 spec = Gem::Specification.new do |s|
     s.platform  =   Gem::Platform::RUBY
     s.name      =   "simplegit"
-    s.version   =   "0.1.0"
+    s.version   =   "0.1.1"
     s.author    =   "Scott Chacon"
     s.email     =   "schacon@gee-mail.com"
     s.summary   =   "A simple gem for using Git in Ruby code."

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index a0a60ae..47c6340 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -18,8 +18,3 @@ class SimpleGit
     end

 end
-
-if $0 == __FILE__
-  git = SimpleGit.new
-  puts git.show
-end
 ```  
Để xem thống kê tóm tắt cho mỗi commit ta có thể sử dụng tùy chọn --stat
```$ git log --stat
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

 Rakefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

 lib/simplegit.rb | 5 -----
 1 file changed, 5 deletions(-)

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit

 README           |  6 ++++++
 Rakefile         | 23 +++++++++++++++++++++++
 lib/simplegit.rb | 25 +++++++++++++++++++++++++
 3 files changed, 54 insertions(+)
```
Ta có thể tự tạo ra output của riêng minh bằng cách sử dụng tùy chọn ```git log pretty=format``` ví dụ:
```\
$ git log --pretty=format:"%h - %an, %ar : %s"
ca82a6d - Scott Chacon, 6 years ago : changed the version number
085bb3b - Scott Chacon, 6 years ago : removed unnecessary test
a11bef0 - Scott Chacon, 6 years ago : first commit
```
Một số tùy chọn cho ```git log --pretty=format:```
Tùy chọn| Mô tả về output
---|----
%h|rút gọn của commit hash
%an|tên tác giả
%ae|email của tác giả
%ar|thời gian thực hiện commit
%s|thông điệp commit
Giới hạn kết quả: Để lọc các kết quả của tập các commit, ví dụ như trong 1 khoảng thời gian nào đấy ta có thể sử dụng các tùy chọn cho ```git log```:

Option|Mô tả
---|---
-<n>|đưa ra n commit gần nhất
--since --after|đưa ra các commit sau mốc thời gian này
--until --before|đưa ra các commit cho đến mốc thời gian này
--author|đưa ra các commit bởi tác giả này
--grep|chỉ đưa ra các commit mà thông điệp commit có chứa string
  
<a name="undo"></a>
### Undo

Một trường hợp xảy ra khi ta commit rồi mà lại quên 1 số file hoặc là viết nhầm thông điệp commit. Khi đó ta có thực hiện lại commit này bằng cách ```add``` các file bị quên và thực hiện lệnh
```
$ git commit --amend
```
1 trình soạn thảo sau đó được hiện lên và ta cũng có thể nhập lại thông điệp commit. Kết quả của là ta có 1 lần commit duy nhất, lần commit thứ 2 kia thay thế kết quả của lần 1.
<a name="unstage"></a>
1. Unstage

Khi ta sửa 2 file và muốn commit nó trong 2 lần khác nhau nhưng không may lại gõ nhầm ```git add *```, thế là cả 2 file đều được stage hết. Khi đó để unstage 1 file ta có thể sử dụng lệnh ```git reset HEAD <file>...```, ví dụ:

     ```
     $ git reset HEAD CONTRIBUTING.md
     Unstaged changes after reset:
    M	CONTRIBUTING.md
    ```
    Ta có thể thấy để unstage thì sử dụng ```git reset```, để tìm kiếm chi tiết có thể tra google.
<a name="unmodified"></a>
2. Unmodified

Sau khi sửa 1 file code nhưng lại thấy trông rối quá ta có thể xóa tất cả thay đổi và cho nó trở về ban đầu sau lần commit cuối( ví dụ lúc clone về). Trong ```git status``` có gợi ý cho việc này:
    ```
    Changes not staged for commit:
    (use "git add <file>..." to update what will be committed)
    (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
    ```
    Sử dụng ```git checkout --<file>...```, ví dụ:
    ```
    $ git checkout -- CONTRIBUTING.md
    ```
    Lưu ý rằng khi sử dụng ```git checkout``` thì những thứ bị xóa đi sẽ không thể hồi phục lại được, nên cần thật cẩn trọng khi sử dụng.
    
<a name="remote"></a>
### Làm việc với các kho chứa từ xa

Kho chứa từ xa là các phiên bản project của bạn được lưu trữ trên Internet hoặc bất cứ đâu trên mạng hoặc có thể nằm trên máy tính của ta luôn.
<a name="view_remote></a>
1. Hiển thị các kho chứa từ xa

Để xem các server đã được cấu hình, sử dụng câu lệnh ```git remote```, nó sẽ liệt kê danh sách têm viết tắt của các server. Nếu project được clone thì ta có thể thấy ```origin```- tên mặc định Git đặt cho server được clone về.
Có thể sử dụng ```git remote -v``` để xem URL tương ứng với tên viết tắt của mỗi server. Ví dụ:
    ```
    $ git remote -v
    origin	https://github.com/schacon/ticgit (fetch)
    origin	https://github.com/schacon/ticgit (push)
    ```
<a name="add_remote"></a>
2. Thêm 1 kho chứa từ xa mới

Để thêm 1 kho chứa từ xa mới sử dụng câu lệnh ```git remote add <shortname> <url>```
trong đó ```shortname``` là tên viết tắt của server dùng cho tiện, còn ```url``` là địa chỉ của server. Ví dụ:
    ```
    $ git remote add pb https://github.com/paulboone/ticgit
    ```
  <a name="fetch_pull"></a>
3. Fetch và pull
  
Sau khi đã thêm 1 kho chứa mới thì nó vẫn chưa có dữ liệu gì, để lấy dữ liệu về ta có thể dùng ```fetch``` hoặc là ```pull```
```fetch``` sẽ kéo tất cả dữ liệu mới nhất từ server về kho chứa trên máy client, tuy nhiên không tự hợp các dữ liệu này với nhánh code ta đang làm việc. Có nghĩa là cập nhật kho chứa nhưng không cập nhật code đang được chỉnh sửa.
```pull``` sẽ làm cả 2 việc này luôn, nên thường xảy ra xung đột giữa nhánh trên máy và trên server.
<a name="push"></a>
4. Push

Push là hành động cập nhật dữ liệu lên server. Sử dụng lệnh ```git push <remote> <branch>```
Việc này thực hiện được chỉ khi ta có quyền ghi trên server và không có ai push cùng lúc. Nếu có 2 người cùng clone project về, sau đó 2 người lần lượt push thì lần push sau sẽ bị hủy bỏ. Người push sau sẽ phải cập nhật dữ liệu từ người kia trước(dùng ```fetch```), sau đó kết hợp code với nhau rồi mới được phép push lại.

<a name="inspect"></a>
5. Xem nhiều thông tin hơn

Để có thể xem được nhiều thông tin hơn từ 1 remote, ta có thể sử dụng lệnh ```git remote show <remote>``` 
Câu lệnh này cho biết nhánh sẽ được cập nhật khi ta sử dụng câu lệnh ```git push```, nhánh nào trên server có mà ta chưa có, nhánh nào mà ta đã xóa từ server, nhánh sẽ được tự động hợp khi ta sử dụng ```git pull```. Ví dụ:
   ```
   $ git remote show origin
   * remote origin
   URL: https://github.com/my-org/complex-project
   Fetch URL: https://github.com/my-org/complex-project
   Push  URL: https://github.com/my-org/complex-project
   HEAD branch: master
   Remote branches:
    master                           tracked
    dev-branch                       tracked
    markdown-strip                   tracked
    issue-43                         new (next fetch will store in remotes/origin)
    issue-45                         new (next fetch will store in remotes/origin)
    refs/remotes/origin/issue-11     stale (use 'git remote prune' to remove)
   Local branches configured for 'git pull':
    dev-branch merges with remote dev-branch
    master     merges with remote master
   Local refs configured for 'git push':
    dev-branch                     pushes to dev-branch                     (up to date)
    markdown-strip                 pushes to markdown-strip                 (up to date)
    master                         pushes to master                         (up to date)
   ```
<a name="rename"></a>
6. Đổi tên và xóa server

Để đổi tên viết tắt của 1 server ```git remote rename <old_name> <new_name>```
Để xóa 1 server ```git remote rm <remote>```
<a name-"tagging"></a>
### Tagging

Tag là việc đánh dấu 1 điểm quan trọng trong lịch sử code.
<a name="view_tag"></a>
1. Xem các tag hiện có

Sử dụng câu lệnh ```git tag```
Ta cũng có thể tìm kiếm tag bằng cách sử dụng pattern, ví dụ:
``` $ git tag -l "v1.8.5*" ```
<a name="creat_tag"></a>
2. Tạo tag

Trong git có 2 loại tag: lightweght và annonated.
Lightweight đơn giản là con trỏ trỏ đến 1 commit nhất định.
Annonated thì là 1 đối tượng đầy đủ được lưu trữ trong cơ sở dữ liệu của Git. Chúng được tính checksum, chứa các thông tin về tên người oánh tag, email, ngày tháng, thông điệp và có thể được chứng thực bởi GCG.

   1. Annotated Tags
   Đẻ tạo 1 annonated tag, thêm tùy chọn ```-a``` khi chạy lệnh ```tag``` ví dụ:
   ```$ git tag -a v1.4 -m "my version 1.4"```
```-m``` chỉ ra thông điệp của tag, nếu không có tùy chọn này Git sẽ bật trình soạn thảo lên và ta có thể nhập thông điệp vào đấy.
Ta có thể xem chi tiết 1 tag bằng câu lệnh ```git show```:
       ```
       $ git show v1.4
       tag v1.4
       Tagger: Ben Straub <ben@straub.cc>
       Date:   Sat May 3 20:19:12 2014 -0700

       my version 1.4

       commit ca82a6dff817ec66f44342007202690a93763949
       Author: Scott Chacon <schacon@gee-mail.com>
       Date:   Mon Mar 17 21:52:11 2008 -0700

       changed the version number
       ```
    2. Lightweight tag
    Đây cơ bản là checksum của commit được lưu trữ trong file. Để tạo nó, không sử dụng bất kì tùy chọn nào cho lệnh ```git tag```, ví dụ:
       ```
       $ git tag v1.4-lw
       ```
       Kết quả khi xem lại tag này:
       ```
       $ git show v1.4-lw
       commit ca82a6dff817ec66f44342007202690a93763949
       Author: Scott Chacon <schacon@gee-mail.com>
       Date:   Mon Mar 17 21:52:11 2008 -0700

       changed the version number
       ```
       Có mỗi checksum và không có thêm thông tin gì khác.
<a name="tag_late"></a>
3. Đánh tag muộn

Sau một vài commit thì bạn chợt nhớ ra là quên chưa đánh tag, may mắn là Git có hỗ trợ đánh tag bằng checksum của commit nên ta đánh tag lúc nào cũng được.
Ví dụ:
   ```
   $ git tag -a v1.2 9fceb02
   ```
   9fcb02 là 1 phần của checksum của commit mà ta soi được từ lịch sử các commit(```git log```).
<a name="tag_share"></a>
4. Chia sẻ tag

Mặc định thì ```git push``` sẽ không truyền các tag tới server. Để gửi kèm các tag này ta sử dụng tùy chọn ```--tags``` trong câu lệnh ```git push``` ví dụ:
   ```
   $ git push origin --tags
   Counting objects: 1, done.
   Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.
   Total 1 (delta 0), reused 0 (delta 0)
   To git@github.com:schacon/simplegit.git
   * [new tag]         v1.4 -> v1.4
   * [new tag]         v1.4-lw -> v1.4-lw
   ```
<a name="alias"></a>
### Alias

Có những câu lệnh dài và khó nhớ ví dụ ```reset HEAD -- <file>``` ta có thể đặt cho nó 1 cái tên khác ngắn và gợi nhớ hơn ví dụ ```unstage``` bằng cách sử dụng lệnh
```
$ git config --global alias.unstage 'reset HEAD --'
```
hoặc có thể đặt tên cho lệnh xem commit cuối cùng :
```
$ git config --global alias.last 'log -1 HEAD'
```
Git thay thế câu lệnh với bất kì cái gì ta đặt cho nó. Nếu muốn chạy 1 lệnh khác mà không phải thuộc tập lệnh của Git, ta bắt đầu câu lệnh đó với dấu ```!```, ví dụ:
```
$ git config --global alias.visual '!gitk'
```
<a name="branch"></a>
## Branch
<a name="over"></a>
### Tổng quan về nhánh trong Git
<a name="khai_niem"></a>
1. Khái niệm nhánh
         
Git không lưu trữ dữ liệu là các thay đổi hay khác nhau giữa các file mà lưu trữ toàn bộ file qua 1 ảnh chụp(snapshot).

   Khi ta thực hiện 1 commit, Git tạo ra 1 đối tượng commit chứa 1 con trỏ tói nội dụng mà ta đánh dấu stage trước đó. Nó cũng bao gồm tên tác giả và email, thông điệp và 1 hay nhiều con trỏ đến các commit ở ngay trước commit này (1 hay nhiều commit cha): 0 cha đối với commit đầu tiên, 1 cha với commit thông thường, nhiều cha đối với commit là kết quả của sự hợp của 2 hay nhiều nhánh.
   
    Để trực quan hóa, giả sử ta có 1 thư mục chứa 3 file, và ta đánh dấu stage cả 3 cho lần commit kế tiếp. Stage các file sẽ tính checksum cho mỗi file (mã SHA-1), lưu phiên bản của file này trong kho chứa Git (trong Git là các blob), và thêm checksum cho vùng staging:
    ```
    $ git add README test.rb LICENSE
    $ git commit -m 'The initial commit of my project'
    ```
    Khi thực hiện lệnh ```git commit```, Git tính checksum cho mỗi thư mục con (ở đây chỉ có 1 thư mục duy nhất là thư mục gốc của project) và tạo ra đối tượng tree (là đối tượng lưu trữ thông tin về thư mục, còn blob là đối tượng lưu trữ thông tin của file). Sau đó, Git tạo ra đối tượng commit chứa metadata và con trỏ trỏ đến đối tượng tree vừa tạo để có thể phục hồi lại ảnh chụp này khi cần.
    
   Kho chứa Git khi này chứa 5 đối tượng: 3 blob( mỗi cái lưu trữ nội dung  của 1 file), 1 tree liệt kê nội dung của thư mục và file tương ứng với blob nào, 1 commit chứa con trỏ trỏ tới cái tree kia và con trỏ trỏ đến các commit cha của nó.

   ![](https://git-scm.com/book/en/v2/images/commit-and-tree.png)

   Khi thực hiện 1 loạt các commit thì commit sau sẽ móc nối với commit trước

   ![](https://git-scm.com/book/en/v2/images/commits-and-parents.png)

   Một nhánh trong Git đơn giản là 1 con trỏ di động có thể trỏ đến 1 trong các commit trên.

   Bình thường khi ta bắt đầu commit thì ta sẽ được cấp 1 con trỏ tên là ```master``` trỏ đến commit cuối cùng đã được tạo (đây cũng chính là nhánh ```master```). Mỗi khi 1 commit mới được tạo ra, con trỏ ```master``` lại tự động dịch lên trước 1 bước.

   ![](https://git-scm.com/book/en/v2/images/branch-and-history.png)
<a name="creat_branch"></a>
2. Tạo 1 nhánh mới

   Điều gì xảy ra nếu ta tạo thêm 1 nhánh mới? Ta sẽ nhận được một con trỏ di động mới để chuyển đổi giữa các nhánh. Để tạo nhánh mới tên là ```testing```, ta thực hiện lệnh ```git branch```:
   ```
   git branch testing
   ```
   Việc này tạo ra 1 con trỏ mới tới commit hiện thời.
   
   ![](https://git-scm.com/book/en/v2/images/two-branches.png)
   
   Để lưu giữ vị trí nhánh đang ở hiện thời Git sử dụng con trỏ ```HEAD```. Câu lệnh ```git branch``` chỉ tạo nhánh mới chứ không chuyển vị trí tới nhánh này.
   
   ![](https://git-scm.com/book/en/v2/images/head-to-master.png)
   
   Ta có thể dễ dàng quan sát bằng việc sử dụng câu lệnh ```git log``` cho kết quả vị trí của các con trỏ nhánh.
   
   ```
   $ git log --oneline --decorate
   f30ab (HEAD -> master, testing) add feature #32 - ability to add new formats to  the central interface
   34ac2 Fixed bug #1328 - stack overflow under certain conditions
   98ca9 The initial commit of my project
    ```  
    2 nhánh ```master``` và ```testing``` đều đang trỏ vào commit có checksum rút gọn là ```f30ab```
<a name="switch"></a>
3. Chuyển nhánh

   Để chyển tới nhánh khác, chạy lệnh ```git checkout```, ví dụ chuyển qua nhánh ```testing```:

   ```
   $ git checkout testing
   ```
   
   ```HEAD``` bây giờ đã trỏ về ```testing```
   
   ![](https://git-scm.com/book/en/v2/images/head-to-testing.png)
   
   Bây giờ hãy tạo thử 1 commit mới:
   
   ```
   $ vim test.rb
   $ git commit -a -m 'made a change'
   ```
   
   ![](https://git-scm.com/book/en/v2/images/advance-testing.png)
    
    Ta thấy commit mới này trỏ vào vị trí mà ```testing``` đang trỏ ```f30ab```, sau đó ```testing``` lại dịch lên 1 bước trỏ vào commit mới này.
    
    Ta thấy rằng ```testing``` đã di chuyển còn ```master``` vẫn đứng yên ở đấy, bây giờ hãy chuyển lại về ```master```:
    ```
    $ git checkout master
    ```
    
    Việc thực hiện câu lệnh trên đem lại 2 kết quả: chuyển con trỏ ```HEAD``` về ```master``` và chuyển tất cả các file trong thư mục làm việc về thời điểm của commit mà ```master``` đang trỏ. Rõ ràng, phiên bản phần mềm trên 2 nhánh giờ đã khác nhau từ lúc con trỏ ```testing``` dịch chuyển.
    
    Ngoài ra, khi ta chuyển nhánh thì tất cả các file trong thư mục làm việc đều thay đổi. Nếu Git không thể thay đổi các file này hoàn toàn thì ta không thể chuyển nhánh được.
     
    Từ bây giờ ta có thể chuyển tới 1 nhánh, chỉnh sửa vài cái, commit rồi lại chuyển sang nhánh khác rồi lại chỉnh chỉnh. Tất cả các thay đổi đều là riêng biệt trên các nhánh khác nhau: ta có thể chuyển giữa các nhánh và có thể hợp chúng lại khi cần.
    
    Bởi vì 1 nhánh trong Git chỉ là 1 file chứa 40 kí tự của mã SHA-1 của commit mà nó đang trỏ , việc tạo hủy nhánh là tức thời. Việc lưu giữ lại cha của các commit cũng giúp việc hợp nhánh trở nên tự động hóa và rất dễ thực hiện.

<a name="pnnhn"></a>
### Phân nhánh và hợp nhánh

Hãy lấy 1 ví dụ về việc phân nhánh và hợp nhánh ngoài đời thật:
1. Ta xây dựng 1 website và đã có 1 phiên bản hoàn chỉnh cho nó
2. Nhưng lại muốn cải tiến nên tạo 1 nhánh mới để cài đặt các cải tiến này
3. Làm 1 vài việc trên nhánh mới này

Thể nhưng, đang cải tiến thì trang web bị lỗi, vì vậy cần sửa ngay:

1. Quay trở lại với nhánh của sản phẩm 
2. Tạo 1 nhánh mới để sửa lỗi
3. Lỗi được sửa xong và hợp nhánh này với sản phẩm 
4. Quay trở lại với nhánh cải tiến
<a name="pn"></a>
#### Phân nhánh

Ban đầu, ta chỉ có 1 nhánh duy nhất là ```master``` mà sản phẩm lúc này chạy ổn dịnh.

![](https://git-scm.com/book/en/v2/images/basic-branching-1.png)

Ta muốn cải tiến trang web và tạo ra nhánh mới tên là ```iss53``` để thử. Để tạo 1 nhánh mới và chuyển sang nhánh này luôn ta sử dụng câu lệnh ```git branch``` với tùy chọn ```-b```:

   ```
   $ git checkout -b iss53
   Switched to a new branch "iss53"
   ```
   ![](https://git-scm.com/book/en/v2/images/basic-branching-2.png)
   
   Ta thử cái tiến trang web này và tạo ra vài commit mới trên nhánh ```iss53```, việc này làm cho nhánh ```iss53``` chạy về phía trước (con trỏ ```iss53```):
   
   ![](https://git-scm.com/book/en/v2/images/basic-branching-3.png)
   
   Đang làm thì có vấn đề xảy ra với website và ta cần sửa nó ngay lập tức. Với Git, ta không cần sửa lỗi này trên nhánh ```iss53``` hay cũng không cần phải xóa hết thay đổi trên nhánh ```iss53``` để quay về phiên bản trang web đang hoạt động. Đơn giản chỉ cần quay lại nhánh ```master```.
   
   Tuy nhiên, trước khi làm việc này, nếu ta vẫn còn vài thay đổi trên nhánh ```iss53``` chưa được commit mà xung đột với nhánh ```master``` thì Git sẽ không cho chuyển nhánh. Cần phải dọn dẹp trước khi chuyển nhánh. Vấn đề này có tên là ```Stashing and Cleaning```. Để đơn giản, cho rằng ta dã commit hết mọi thay đổivà có thể chuyển ngay đến nhánh ```master```:
   
   ```
    $ git checkout master
    Switched to branch 'master'
   ```
   
   Từ bây giờ, thư mục làm việc sẽ trở về như trước lúc tạo nhánh ```iss53``` và ta bắt đầu sửa lỗi. Khi chuyển nhánh thì Git sẽ reset thư mục làm việc về thời điểm ta tạo commit cuối cùng trên nhánh này.
   
   Ta tạo 1 nhánh nữa là ```hotfix``` để sửa lỗi cho chắc không làm ảnh hưởng đến ```master``:
   
   ```
   $ git checkout -b hotfix
   Switched to a new branch 'hotfix'
   $ vim index.html
   $ git commit -a -m 'fixed the broken email address'
   [hotfix 1fb7853] fixed the broken email address
  1 file changed, 2 insertions(+)
  ```
  
  ![](https://git-scm.com/book/en/v2/images/basic-branching-4.png)
  
  Sau khi test chán chê thì ta cũng sửa được lỗi. Bây giờ cần hợp ```hotfix``` với ```master``` để đánh dấu phiên bản xịn nhất của trang web này. Thực hiện bằng câu lệnh ```git merge```:
  
  ```
  $ git checkout master
  $ git merge hotfix
  Updating f42c576..3a0874c
  Fast-forward
  index.html | 2 ++
  1 file changed, 2 insertions(+)
  ```
  
  Ở đây xuất hiện cụm từ  "fast-forward" vì commit số hiệu ```C4``` -được trỏ bởi ```hotfix``` là nhánh cần hợp, ở ngay phía trước commit ```C2```- được trỏ bởi ```master``` là nhánh hiện tại, Git đơn giản là chuyển con trỏ lên phía trước.Khi ta hợp 1 commit với 1 commit là tổ tiên của nó.
  
  ![](https://git-scm.com/book/en/v2/images/basic-branching-5.png)
  
 Bây giờ, ta có thể xóa nhánh ```hotfix``` đi được rồi:
 
```
$ git branch -d hotfix
Deleted branch hotfix (3a0874c).
```

Sau đó chuyển lại về ```iss53``` để làm tiếp:
```
$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'
[iss53 ad82d7a] finished the new footer [issue 53]
1 file changed, 1 insertion(+)
```

![](https://git-scm.com/book/en/v2/images/basic-branching-6.png)

Rõ ràng, việc ta làm trên nhánh ```hotfix``` đã không ảnh hưởng gì đến các file trên nhánh ```iss53```
<a name="hn"></a>
#### Hợp nhánh

Bây giờ, ta thấy rằng việc cải tiến đã xong và nhánh ```iss53``` và sẵn sàng để hợp với nhánh ```master``` tạo ra phiên bản ổn định mới. Tương tự như trên, sử dụng câu  lệnh ```git merge```:

```
$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)
```

Kết quả bây giờ đã khác, các nhánh đã có sự phân hóa. Commit mà ta đang đứng bây giờ không còn là tổ tiên của nhánh cần hợp nữa rồi. Trong trường hợp này, Git sẽ hợp ba bước, sử dụng 2 ảnh chụp (snapshot) được trỏ bởi 2 nhánh cần hợp và tổ tiên chung của chúng.

![](https://git-scm.com/book/en/v2/images/basic-merging-1.png)

Thay vì dịch con trỏ lên phía trước, Git tự động tạo ra 1 ảnh chụp là kết quả của việc hợp 3 bước và tạo ra 1 commit mới trỏ đến nó. Đây là "merge commit" và điều đặc biệt là nó có tới 2 thằng cha.

![](https://git-scm.com/book/en/v2/images/basic-merging-2.png)

Giờ có thể xóa nhánh ```iss53``` được rồi.
<a name="conflict"></a>
### Xung đột khi hợp

Đôi khi việc hợp là không mượt. Nếu ta thay đổi cùng 1 chỗ trên cùng 1 file trên 2 nhánh cần hợp, Git không có khả năng hợp chúng lại hoàn toàn. Ta có thể nhận được xung đột như sau:

```
$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
```

Git lúc này sẽ không tự động tạo "merge commit" nữa. Nó dừng việc hợp lại cho đến khi xung đột được giải quyết. Nếu muốn xem file nào chưa được được hợp lại sau khi xảy ra xung đột, ta có thể sử dụng ```git status```:

```
$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

    both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")
```

Git sẽ đánh dấu các chỗ trong file bị xung đột, ta có thể mở file và giải quyết xung đột bằng tay.

```
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
```

File bị xung đột là index.html. Bản trong ```HEAD```( nhánh ```master```, vì ta chạy lệnh ```check out``` nó) là phần trên của đoạn này (phía trên ```=======```), bản trong nhánh ```iss53``` nằm phía dưới cái dấu kia. Để giải quyết xung đột, ta cần sửa cái file này tùy theo ý mình. Ví dụ như sau:

```
<div id="footer">
please contact us at email.support@github.com
</div>
```

Các cái dấu đã bị bỏ đi hết ```>>>>>```, ```======```, ```<<<<<```. Sau khi sửa xong thì ta có thể đánh dấu stage nó bằng ```git add``` để đánh dấu cho Git biết là file này đã giải quyết rồi.

Sau khi giải quyết hết xung đột, ta có thể xem lại bằng ```git status```:

```
$ git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

    modified:   index.html
```

Đến đây, ta vui mừng vì đã sửa hết xung đột và quyết định kết thúc việc hợp. Sử dụng ```git commit```, thông điệp commit mặc định trông như sau:

```
Merge branch 'iss53'

Conflicts:
    index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
#	.git/MERGE_HEAD
# and try again.


# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
#
# Changes to be committed:
#	modified:   index.html
#
```

ta có thể sửa lại cái thông điệp này theo ý mình.
<a name="quan_li"></a>
#### Quản lí nhánh

Nếu sử dụng câu lệnh ```git branch``` không có tham số, ta sẽ có danh sách các nhánh hiện có:

```
$ git branch
  iss53
* master
  testing
```

Dấu ```*``` đánh dấu nhánh hiện tại ta đang đứng(trỏ bởi ```HEAD```). Để xem commit cuối trên mỗi nhánh sử dụng lệnh ```git branch -v```:

```
$ git branch -v
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch 'iss53'
  testing 782fd34 add scott to the author list in the readmes
```

2 tùy chọn hữu ích là ```--merged``` và ```--no-merged``` lọc ra các nhánh đã được hợp và chưa được hợp với nhau. Để xem nhánh nào đã được hợp với nhánh ta đang đứng ```git branch --merged```:

```
$ git branch --merged
  iss53
* master
```

VÌ ta đã hợp ```iss53``` trước đó nên sẽ thấy nó trong danh sách. Nhánh không có dấu ```*``` có thể xóa đi được vì mọi việc làm trên nhánh này đã được sáp nhập và không mất mát gì khi xóa.

Có thể thêm xem nhánh nào chưa hợp với nhánh ```master```:

```
$ git checkout testing
$ git branch --no-merged master
  topicA
  featureB
```

Để xem các nhánh chưa được hợp ```git branch --no-merged```:

```
$ git branch --no-merged
  testing
```

Nhánh này chứa các phần việc chưa được hợp lại nên xóa bằng ```git branch -d``` là không được:

```
$ git branch -d testing
error: The branch 'testing' is not fully merged.
If you are sure you want to delete it, run 'git branch -D testing'.
```

Vẫn có thể ép xóa bằng tùy chọn ```-D```.
<a name="remote_branch"></a>
#### Remote Branch

1 nhánh thực ra chỉ là 1 con trỏ trỏ tới 1 commit. Nhánh theo dõi từ xa (Remote-tracking branch) là tham chiếu tới trạng thái của nhánh từ xa này. Nó là các con trỏ  trong cơ sở dữ liệu mà ta không dịch chuyển được như con trỏ nhánh thông thường, Git sẽ dịch chuyển nó khi ta kết nối với server, để đảm bảo mô tả trạng thái chính xác của kho chứa từ xa. Nó giống như bookmark, nhắc ta về trạng thái của các nhánh lần cuối ta kết nối tới server.

Nhánh theo dõi từ xa có dạng ```<remote>/<branch>```. Ví dụ, nếu muốn xem nhánh ```master``` trong remote ```origin``` trông thế nào tại lần cuối cập nhật, cần kiểm tra nhánh có tên ```origin/master```. 

Lấy ví dụ như sau, giả sử ta có 1 cái Git server ở địa chỉ ```git.ourcompany.com```.Nếu sử dụng lệnh ```clone``` để sao kho chứa trên server này về, Git sẽ tự động tạo remote tên là ```origin```, tạo 1 con trỏ đến vị trí hiện tại của nhánh ``` master``` , đặt tên là ```origin/master```. Git cũng tạo 1  nhánh ```master``` để ta có thể làm việc trên đó.

![](https://git-scm.com/book/en/v2/images/remote-branches-1.png)

Nếu ta làm việc trên nhánh ```master``` và cùng lúc đó có người cập nhật nhánh ```master``` trên server thì 2 nhánh giờ có sự khác biệt. Cho đến khi ta liên lạc với server thì nhánh ```origin/master``` không dịch chuyển.

![](https://git-scm.com/book/en/v2/images/remote-branches-2.png)

Để đồng bộ công việc, ta cần chạy ```git fetch origin```. Lệnh này tìm server có tên là ```origin```( ở đây là ```git.ourcompany.com```), tìm nạp tất cả dữ liệu mà ta chưa có và cập nhật cơ sở dữ liệu, dịch chuyên con trỏ ```origin/master``` về vị trí mới cập nhật.

![](https://git-scm.com/book/en/v2/images/remote-branches-3.png)

<a name="pushing"></a>
1. Pushing

  Để chia sẻ 1 nhánh với mọi người, ta cần đẩy nó lên server có quyền ghi. Việc đẩy là không tự động nên cần thực hiện bằng tay mỗi khi muốn.
  Nếu ta có 1 nhánh tên là ```serverfix``` muốn đẩy lên chạy lệnh ```git push <remote> <branch>```:

   ```
   $ git push origin serverfix
   Counting objects: 24, done.
   Delta compression using up to 8 threads.
   Compressing objects: 100% (15/15), done.
   Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
   Total 24 (delta 2), reused 0 (delta 0)
   To https://github.com/schacon/simplegit
    * [new branch]      serverfix -> serverfix
   ```
   
     Ta cũng có thể thực hiện ```git push origin serverfix:serverfix```, có nghĩa là "lấy nhánh serverfix trên máy này của tao và cập nhật nó lên trên nhánh serverfix của server". Như thế, ta có thể sử dụng định dạng này để đẩy 1 nhánh lên nhánh khác tên khác nhau.
     
    Khi sử dụng ```git fetch``` để cập nhật nhánh theo dõi từ xa, ví dụ nhánh ```serverfix``` thì nhánh được cập nhật là ```origin/serverfix``` chứ không phải ```severfix``` trên máy. Mà nhánh này ta không thể sửa đổi được, thể nên cần hợp 2 nhánh trên với nhau trước khi nhìn thấy cập nhật mới để làm. Chạy lệnh ``` git merge origin/serverfix``` để hợp 2 nhánh.
    
    Nếu nhánh ```serverfix``` chưa được tạo, ta có thể tạo nó dựa trên ```origin/serverfix``` để làm việc:
    
    ```
    $ git checkout -b serverfix origin/serverfix
    Branch serverfix set up to track remote branch serverfix from origin.
    Switched to a new branch 'serverfix'
    ```
 <a name="tracking"></a>   
 2. Tracking branch
    Để tiện làm việc thì ta có thể gán quan hệ giữa 1 nhánh trên máy với 1 nhánh từ xa để khi sử dụng ```git pull``` hoặc ```git push``` thì Git sẽ tự động biết nhánh nào trên server cần làm việc.
    Có thể dùng lệnh ```git checkout -b <branch> <remote>/<branch>``` như trên. Hay đơn giản hơn có thể dùng tùy chọn ```--track```:
    
    ```
    $ git checkout --track origin/serverfix
    Branch serverfix set up to track remote branch serverfix from origin.
    Switched to a new branch 'serverfix'
    ```
    
    Tên của 2 nhánh có thể là khác nhau
   
    ```
    $ git checkout -b sf origin/serverfix
    Branch sf set up to track remote branch serverfix from origin.
    Switched to a new branch 'sf'
    $ git checkout -b sf origin/serverfix
    Branch sf set up to track remote branch serverfix from origin.
    Switched to a new branch 'sf'
    ```
    
    Có thể xem toàn bộ các quan hệ bằng ```git branch -vv```:
    
    ```
    $ git branch -vv
    iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
     master    1ae2a45 [origin/master] deploying index fix
    * serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
    testing   5ea463a trying something new
    ```
 <a name="pulling"></a>
3. Pulling
    
    Trong khi ```git fetch``` chỉ đơn gian cập nhât cho nhánh từ xa mà không cập nhật nhánh có quan hệ với nhánh này, kết quả là thư mục làm việc sẽ không đổi. ```git pull``` thì là sự kết hợp của ```git fetch``` và ```git merge```
 <a name="xoa"></a>
4. Xóa
   
   Để xóa 1 nhánh trên server ta có thể sử dụng câu lệnh ```git push``` với tùy chọn ```--delete```:

   ```
   $ git push origin --delete serverfix
   To https://github.com/schacon/simplegit
   - [deleted]         serverfix
   ```
<a name="rebase"></a>
#### Rebase

   Trong Git, có 2 cách để hợp nhánh: ```merge``` và ```rebase```.

   Trong phần hợp nhánh, việc hợp nhánh tạo ra 1 commit mới có nhiều cha.

   ![](https://git-scm.com/book/en/v2/images/basic-rebase-2.png)

   Với ```rebase```, ta có thể lặp lại các thay đổi được commit trên 1 nhánh trên 1 nhánh khác.

   Ví dụ, ta thực hiện lệnh:

   ```

   $ git checkout experiment
   $ git rebase master
   First, rewinding head to replay your work on top of it...
   Applying: added staged command
   ```
   
   Câu lệnh thực hiện như sau: tìm tổ tiên chung của 2 nhánh, xác định sự thay đổi trong mỗi commit của 2 nhánh với nhau và ghi vào 1 file tạm thời, reset các commit của nhánh hiện tại thành các commit của nhánh cần rebase vào, cuối cùng sửa các commit này bằng các ghi chép từ file hiện thời phía trên.
   
   ![](https://git-scm.com/book/en/v2/images/basic-rebase-3.png)
   
   Cuối cùng ```C4'``` giống với ```C5``` trong phần hợp nhánh. kết quả là giống nhau nhưng ```rebase``` được sử dụng để tạo ra lịch sử đẹp hơn. Nếu nhìn vào lịch sử của nhánh đã được rebase thì ta thấy nó gần như là tuyến tính, tạo thành 1 chuỗi liền mạch.
   
   Nên sử dụng ```rebase``` với các thay đổi trên các nhánh cục bộ để làm sạch lịch sử, nhưng không bao giờ ```rebase``` những thứ được push về.

<a name="tailieu"></a>
### Tài liệu tham khảo

[1] [https://git-scm.com/docs](https://git-scm.com/docs)

[2] [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2)
   
   
   
